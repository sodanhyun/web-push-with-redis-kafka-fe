# 🚀 웹 푸시 및 실시간 알림 프론트엔드

이 프로젝트는 React, TypeScript, Vite로 구축된 프론트엔드 애플리케이션으로, 웹 푸시 알림 및 WebSocket을 이용한 실시간 통신 기능을 시연합니다.

## ✨ 주요 기능

*   **푸시 알림**: 서비스 워커를 통해 백그라운드에서도 푸시 이벤트를 수신하고 시스템 알림을 표시합니다.
*   **실시간 통신**: WebSocket을 사용하여 백엔드로부터 크롤링 진행 상황과 같은 실시간 데이터를 수신하고 화면에 표시합니다.
*   **크롤링 스케줄 관리**: Cron 표현식을 사용하여 백엔드에 크롤링 작업을 예약, 조회, 수정, 취소할 수 있는 인터페이스를 제공합니다.
*   **토스트 UI**: 푸시 알림 수신, 클릭 등 다양한 이벤트에 대한 인앱 토스트 메시지를 제공합니다.
*   **HTTPS 개발 환경**: `mkcert`를 활용하여 로컬에서도 신뢰할 수 있는 HTTPS 환경을 자동으로 구성합니다.

## 🛠️ 기술 스택

*   **프레임워크**: React 19, Vite
*   **언어**: TypeScript
*   **HTTP 클라이언트**: Axios
*   **실시간 통신**: WebSocket API
*   **푸시 기술**: Service Worker, Push API, Notification API
*   **스타일링**: CSS

## ⚡️ PWA (Progressive Web App) 기능

이 애플리케이션은 PWA로 구현되어 다음과 같은 추가적인 기능을 제공합니다.

*   **앱 설치**: 데스크톱이나 모바일 홈 화면에 앱을 설치하여 네이티브 앱처럼 사용할 수 있습니다.
*   **오프라인 지원**: 앱의 핵심 자원(App Shell)이 캐싱되어 오프라인 상태에서도 앱을 로드하고 기본 기능을 사용할 수 있습니다.
*   **백그라운드 알림**: 서비스 워커를 통해 앱이 완전히 종료된 상태에서도 푸시 알림을 수신할 수 있습니다.

> **🎨 아이콘 교체 안내**
> 현재 PWA 아이콘은 임시로 `vite.svg` 파일을 사용하고 있습니다. 프로덕션 환경에서는 `public/manifest.webmanifest` 파일의 `icons` 경로와 실제 아이콘 파일들을 교체해야 합니다. 다양한 크기의 아이콘을 쉽게 생성하려면 [Favicon.io](https://favicon.io/)와 같은 온라인 도구를 사용하는 것을 권장합니다.

---

## 📦 설치 및 실행

이 프로젝트를 실행하려면 **Node.js (v18 이상)** 및 **npm**이 필요합니다.

### 1. 저장소 클론 및 의존성 설치

```bash
# 프론트엔드 프로젝트 디렉토리로 이동
cd web-push-with-redis-kafka-fe

# npm 패키지 설치
npm install
```

### 2. 로컬 HTTPS 인증서 생성

웹 푸시 및 서비스 워커는 보안 컨텍스트(HTTPS)에서만 동작하므로, 로컬 개발 환경에 HTTPS 설정이 필수입니다.

**`mkcert`를 사용한 자동 설정 (권장)**

`mkcert`는 로컬에서 브라우저가 신뢰하는 SSL 인증서를 쉽게 만들어주는 도구입니다.

```bash
# 1. mkcert 설치 (아직 설치하지 않은 경우)
# macOS: brew install mkcert
# Windows (Chocolatey 사용): choco install mkcert

# 2. 로컬 인증 기관(CA) 설정
mkcert -install

# 3. 인증서 생성 스크립트 실행
npm run setup:https:mkcert
```

위 과정을 완료하면 프로젝트 루트에 `certs` 디렉토리가 생성되고 그 안에 `localhost-key.pem`과 `localhost.pem` 파일이 저장됩니다.

### 3. 환경 변수 설정

프로젝트 루트(`web-push-with-redis-kafka-fe`)에 `.env` 파일을 생성하고 백엔드 VAPID 키를 설정합니다.

```.env
# 백엔드에서 생성된 VAPID 공개 키를 입력하세요.
VITE_APP_VAPID_PUBLIC_KEY=YOUR_VAPID_PUBLIC_KEY_HERE
```

> **VAPID 키란?**
> 푸시 서버에 "누가" 푸시 메시지를 보냈는지 식별하기 위한 보안 키입니다. 백엔드 프로젝트의 `README.md`를 참조하여 키를 생성하고, 여기서 생성된 **공개 키**를 위 변수에 붙여넣으세요.

### 4. 개발 서버 실행

```bash
npm run dev
```

서버가 실행되면 브라우저에서 **`https://localhost:5173`** 주소로 접속하세요.

## 🎯 사용법

1.  **권한 요청**: "권한 요청" 버튼을 클릭하여 브라우저 알림 권한을 허용합니다.
2.  **푸시 구독**: "푸시 알림 구독" 버튼을 클릭하여 이 브라우저를 푸시 서비스에 등록합니다. 이 정보는 백엔드 서버에 저장됩니다.
3.  **테스트 알림**: "테스트 푸시 알림 보내기" 버튼으로 백엔드를 통해 테스트 알림을 전송할 수 있습니다.
4.  **크롤링 시작**: "크롤링 시작" 버튼을 누르면 백엔드에서 크롤링 프로세스가 시작되며, WebSocket을 통해 실시간 진행 상황을 확인할 수 있습니다.
5.  **크롤링 스케줄 관리**: 스케줄 관리 섹션에서 사용자 ID와 Cron 표현식을 입력하여 크롤링 작업을 예약하고, 등록된 스케줄을 확인, 수정 또는 취소할 수 있습니다.

---

## 📚 아키텍처 및 코드 설명

### 1. 전체 구조

이 애플리케이션은 **메인 앱(React)**과 **서비스 워커** 두 가지 주요 부분으로 나뉩니다.

*   **메인 앱**: 사용자가 보는 UI를 렌더링하고, 버튼 클릭과 같은 상호작용을 처리하며, 백엔드 API와 직접 통신합니다.
*   **서비스 워커 (`public/sw.js`)**: 브라우저 백그라운드에서 실행되는 스크립트입니다. 앱이 꺼져 있어도 푸시 알림을 수신하고, 시스템 알림을 표시하는 역할을 담당합니다.

이 둘은 `BroadcastChannel` API를 통해 서로 메시지를 주고받습니다.

### 2. 주요 파일 및 디렉토리

#### `public/sw.js` (서비스 워커)
*   **역할**: 백그라운드에서 푸시 이벤트를 수신하고 시스템 알림을 생성합니다.
*   **주요 로직**:
    *   `push` 이벤트 리스너: 백엔드로부터 푸시 메시지를 받으면 `self.registration.showNotification()`을 호출하여 화면에 시스템 알림을 표시합니다.
    *   `notificationclick` 이벤트 리스너: 사용자가 알림을 클릭했을 때 지정된 URL을 열거나 앱 창에 포커스를 맞춥니다.

#### `src/hooks/usePushNotification.ts`
*   **역할**: 웹 푸시 관련 모든 클라이언트 로직(지원 여부 확인, 권한 요청, 구독/구독 취소)을 캡슐화한 커스텀 훅입니다.
*   **주요 로직**:
    *   서비스 워커를 등록하고 브라우저의 푸시 기능 지원 여부를 확인합니다.
    *   푸시 알림 권한 상태를 관리합니다.
    *   VAPID 공개 키를 사용하여 브라우저를 푸시 서비스에 구독시키고, 생성된 `PushSubscription` 객체를 반환합니다.

#### `src/App.tsx`
*   **역할**: 애플리케이션의 메인 컴포넌트입니다.
*   **주요 로직**:
    *   `usePushNotification` 훅을 사용하여 푸시 관련 상태와 기능을 관리합니다.
    *   생성된 푸시 구독 정보를 `pushApi`를 통해 백엔드로 전송합니다.
    *   `WebSocketTest` 컴포넌트를 렌더링하여 실시간 통신 기능을 통합합니다.
    *   `NotificationContainer`를 통해 인앱 토스트 알림을 표시합니다.

#### `src/components/`
*   **`WebSocketTest.tsx`**: 실시간 WebSocket 통신을 시연하는 컴포넌트입니다. 백엔드에 연결하여 크롤링 진행 데이터를 받아 화면에 표시합니다.
*   **`NotificationToast.tsx`**: 인앱 토스트 알림 UI와 상태 관리를 담당합니다. 서비스 워커나 다른 컴포넌트로부터 `window` 이벤트를 받아 새 토스트를 표시합니다.
*   **`CrawlingScheduler.tsx`**: 크롤링 스케줄 작업을 추가, 조회, 수정, 취소할 수 있는 인터페이스를 제공하는 컴포넌트입니다. 백엔드 API와 연동하여 스케줄을 관리합니다.

#### `src/api/`
*   **역할**: `axios`를 사용하여 백엔드 API와 통신하는 모듈입니다.
*   **`pushApi.ts`**: 푸시 구독 정보를 백엔드에 등록하고, 테스트 알림 전송을 요청합니다.
*   **`crawlingApi.ts`**: 백엔드의 크롤링 프로세스 시작을 요청합니다.
*   **`scheduleApi.ts`**: 크롤링 스케줄 작업을 관리하기 위한 API 호출 함수들을 제공합니다. (추가, 조회, 취소, 업데이트)
